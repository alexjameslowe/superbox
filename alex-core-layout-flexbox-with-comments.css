/*clear the defaults.*/
* {
  margin: 0px;
  padding: 0px;
  border: 0px;
  /*border: 1px solid red;*/
}

/*https://css-tricks.com/removing-the-dotted-outline/ 
get rid of that annoying dotted border around links.*/
a {
  outline: 0;
}

body,
html {
  height: 100%;
}

/*An al element by default is just a row.*/
.al {
  display: flex;
  flex: 0 0 100%;
  -ms-flex: 0 0 100%;
  flex-wrap: nowrap;
  box-sizing: border-box;
  position: relative; /*For absolutely positioned children*/
}


/*the row container. */
.al.al-rows {
  flex-wrap: wrap;
}
/*the box container. the nowrap forces this to conserve horizontal space */
.al.al-boxes {
  flex-wrap: nowrap;
}

/*elements in a rows container will behave like rows*/
.al.al-rows > .al {
  flex: 0 0 100%;
  -ms-flex: 0 0 100%;
}
/*elements in a boxes container will behave like boxes*/
.al.al-boxes > .al {
  flex: 0 0 auto;
  -ms-flex: 0 0 auto;
}
/**
 * This mysterious flex-align:start style. What's deal here?
 * This causes content boxes to have a frugal widths or heights along the secondary
 * dimension.
 *
 * An h-mode box has a primary dimension of x and a secondary dimension of y.
 * the x-dimension is conserved with greedy/frugal rules. The secondary dimension is y, 
 * and this secondary dimension has two modes: either take up all the height it can or 
 * it will take up height frugally. The default is to take up all the height which you can 
 * see in the examples: horizontal-mode-primary test #1.
 *
 * This class switches this behavior to the alternate mode. So in the case of h-mode boxes,
 * they will height themselves frugally.
 *
 * The same applied for v-mode boxes.
 *
 * Switching to secondary behavior with this class opens up some possibilities 
 * for adjusting the position of the boxes, which you can see in either 
 * horizontal-mode-secondary-default-and-alternate.html and 
 * vertical-mode-secondary-default-and-alternate.html
 *
 */
.al.al-boxes.al-content-alt-secondary  {
  align-items: flex-start;
}

/**
 * Adding this so that you can space contents.
 *
 */
.al-content-space-around {
  justify-content: space-around;
}
.al-content-space-between {
  justify-content: space-between;
}
.al-content-space-evenly {
  justify-content: space-evenly;
}

/**al-explicit is for h-mode or v-mode elements that have an explict width/height.
 * The al boxes have flex-shrink:0 by default. If there are any al-explicit in a h-mode or v-mode
 * element, then we want the explicit ones to not shrink, but we want the others to be able
 * to shrink in order to accommodate them.*/
.al.al-boxes.al-greedy-1 > .al:not(.al-explicit), 
.al.al-boxes.al-greedy-2 > .al:not(.al-explicit), 
.al.al-boxes.al-greedy-3 > .al:not(.al-explicit), 
.al.al-boxes.al-greedy-4 > .al:not(.al-explicit), 
.al.al-boxes.al-greedy-5 > .al:not(.al-explicit), 
.al.al-boxes.al-greedy-6 > .al:not(.al-explicit) {
  flex-shrink: 1;
}

.al.al-boxes > .al.al-greedy {
  flex: 0 1 auto;
  -ms-flex: 0 1 auto;
}
.al.al-boxes.al-greedy-1 > .al.al-greedy {
  flex-grow: 1;
}
.al.al-boxes.al-greedy-2 > .al.al-greedy {
  flex-grow: 0.5;
}
.al.al-boxes.al-greedy-3 > .al.al-greedy {
  flex-grow: 0.33;
}
.al.al-boxes.al-greedy-4 > .al.al-greedy {
  flex-grow: 0.25;
}
.al.al-boxes.al-greedy-5 > .al.al-greedy {
  flex-grow: 0.2;
}
.al.al-boxes.al-greedy-6 > .al.al-greedy {
  flex-grow: 0.1667;
}


/**
 * flexbox has a weird thing going on with absolutely-positioned children.
 * assigning top:0px will make it break out of the container. don't know why. you'll never know why.
 *
 */
.al-abox {
  position: absolute;
  top: auto;
  left: 0px;
}

/**
 * this gives us a piece of "glass" that covers a row or box.
 * handy for loading messages and modals etc. 
 *
 */
.al-spread {
  position: absolute;
  top: 0px;
  bottom: 0px;
  left: 0px;
  right: 0px;
}

/**
 * This is kind of a weird use-case.
 * The only thing that works in all contexts for this element is the stretch effect,
 * and of course the trade-off is that you have to assign an explicit height to the outer container.
 * This is weird. WIll probably take another crack at this at some point. 
 */
/* .al-h-scroller {
  display: flex;
  position: absolute;
  width: auto;
  left: 0px;
  right: 0px;
  top: 0px;
  right: 0px;
  box-sizing: border-box;
  overflow-x: auto;
  flex-wrap: nowrap;
} */

/**
 * Switch the container to work vertically instead of horizontally.
 *
 */
.al-vertical.al-content-strict-height {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}

/**
 * This allow a the elements in a vertical-conserving element to 
 * generate their own height as they need. This will take up all the
 * height, and then if it goes beyond that, it will add to that height.
 *
 * See the BROKEN-XY-PARITY-NOTE
 * 
 */
.al-vertical {
  display: flex;
  flex: 0 0 auto; 
  width: 100%;
  flex-wrap: nowrap;
  box-sizing: border-box;
  flex-direction: column;
  position: relative; /*For absolutely positioned children*/

  /*We want the the stack to take up all of it available height be default, 
  but if it goes beyond that, then it's going to end up generating height of its own.*/
  height: 100%;
}


/**
 * This is how we treat the width in vertical-conserved elements. We assume that they behave like rows and 
 * take up 100% of the width. Why don't we use flex? See, flex in this case is being used for vertical-conservation.
 * But we don't need anything super-intelligent here. In vertical-conservation, the vertical-conservation rules
 * are complex and have greedy/vs frugal and all that rot, but the width requirements are simple, so we can get
 * away with letting an explict-width of 100% do the work of widthing for us.*/
.al-vertical > .al {
  width: 100%;
}
.al-vertical.al-content-alt-secondary > .al {
  width: auto;
}


/**
* A flip-side to the above argument. If a vertical-mode element (between the > >) switches
* to horizontal-mode for it children (the .al after the last >), then we want the children
* to just take up all the height. But just like the rule above, we can't use flex-box do that,
* because flex-box is being used for horizontal-conservation. So we need to rely on an explicit
* height:100% for that. Same thing. Horizontal-conservation means that horizontal rules are 
* complex and require flex, but the height rules are dead-simple and require height:100%.
* See case-study-wrapper-problem: #Uneccessary Wrapper */
.al-vertical > .al.al-boxes:not(.al-vertical) > .al {
  height: 100%;
}
.al-vertical > .al.al-boxes.al-content-alt-secondary:not(.al-vertical) > .al {
  height: auto;
}


/**
 * This is for vertical greedy elements.
 * we need this so that when greedy vertical elements have contents that are too high or long 
 * it won't expand the height of the greedy element.
 */
.al-vertical.al-boxes.al-content-strict-height > .al.al-greedy {
  overflow-y: auto;
}

/**
 * In addition to flex-grow, vertical greedy elements, need flex-basis for some reason.
 *
 */
.al-vertical.al-greedy-1 > .al.al-greedy {
  flex-basis: 100%;
}
.al-vertical.al-greedy-2 > .al.al-greedy {
  flex-basis: 50%;
}
.al-vertical.al-greedy-3 > .al.al-greedy {
  flex-basis: 33%;
}
.al-vertical.al-greedy-4 > .al.al-greedy {
  flex-basis: 25%;
}
.al-vertical.al-greedy-5 > .al.al-greedy {
  flex-basis: 20%;
}
.al-vertical.al-greedy-6 > .al.al-greedy {
  flex-basis: 16.67%;
}

/**
 * Used for centering, justifying
 */
.al.al-boxes.al-content-center-v, .al.al-rows.al-content-center-v {
  align-items: center;
}

/**
 * for vertical, we have to switch to align-items for horizontal centering.
 * Otherwise, we can use justify-content. Has to do with flexbox cross-axis.
 */
.al.al-vertical.al-boxes.al-content-alt-secondary.al-content-center-h {
  align-items: center;
}
.al.al-boxes.al-vertical.al-content-center-v, .al.al-boxes.al-content-center-h {
  justify-content: center;
}


/**
 * align content boxes right, left, top, bottom, for both
 * the h-mode and v-mode containers.
 */
.al.al-boxes.al-content-to-left, .al.al-vertical.al-boxes.al-content-to-top {
  justify-content: flex-start;
}
.al.al-boxes.al-content-to-right, .al.al-vertical.al-boxes.al-content-to-bottom {
  justify-content: flex-end;
}
.al.al-vertical.al-boxes.al-content-to-left, .al.al-boxes.al-content-alt-secondary.al-content-to-top {
  align-items: flex-start;
}
.al.al-vertical.al-boxes.al-content-to-right, .al.al-boxes.al-content-alt-secondary.al-content-to-bottom {
  align-items: flex-end;
}


.al.al-boxes.al-content-center {
  align-items: center;
  justify-content: center;
}

/**
 * Use this for text with break tags
 * 
 */
.al.al-text {
  display: block;
}

/*for the al-boxes container. This is a new sibling of al-greedy, al-frugal.
al-uniform. So, there are three uniform elements which means give them a 
flex width of 33% and tell them to hold it with the grow and shrink set to 1.*/
.al.al-boxes.al-uniform-2 > .al {
  flex: 1 1 50%;
}
.al.al-boxes.al-uniform-3 > .al {
  flex: 1 1 33%;
}
.al.al-boxes.al-uniform-4 > .al {
  flex: 1 1 25%;
}
.al.al-boxes.al-uniform-5 > .al {
  flex: 1 1 20%;
}

/*This is an experimental set of classes for making uniform "gutters". 
The container gets 20px padding. Then all the rows except the first one
get 20px margin-top, and the result is a nice even gutter of 20px everywhere
in the container. And this is responsive too. Tested in IE11. Not sure
how this would work with the al-content-space* classes.*/
.al.al-boxes.al-g20, .al.al-rows.al-g20 {
  padding:20px;
}
.al.al-boxes.al-g30, .al.al-rows.al-g30 {
  padding:30px;
}
.al.al-boxes.al-g40, .al.al-rows.al-g40 {
  padding:40px;
}
/*These :not(div:first-of-type) are so you can have an absolute positioned elemement at the front
and it won't mistakenly get this style, just as long as you don't use a div. So you use
something like <span class="al-spread">*/
.al.al-boxes.al-g20 > .al:not(div:first-of-type), .al.al-rows.al-g20 > .al:not(div:first-of-type) {
  margin-left:20px;
}
.al.al-boxes.al-g30 > .al:not(div:first-of-type), .al.al-rows.al-g30 > .al:not(div:first-of-type) {
  margin-left:30px;
}
.al.al-boxes.al-g40 > .al:not(div:first-of-type), .al.al-rows.al-g40 > .al:not(div:first-of-type) {
  margin-left:40px;
} 


/*
Image features. 
The al-greedy-img-wrap is meant for situations where you want the image to occupy a greedy element.
See example-100vh-with-big-image to see this in action.
Right now it's only geared to work in vertical-conserved situations.
*/
.al.al-vertical > .al-greedy > .al-img-fill {
  position: absolute;
  display: flex;
  left:0px;
  right:0px;
  top:0px;
  bottom:0px;
}
.al-img-fill > img {
  width:100%; 
  height:100%; 
  object-position:50% 50%; 
  object-fit:cover;
}
.al-img-contain > img {
  object-fit:contain;
}


/*Greater-Than classes. Mobile-first. Your default classes in this case would correspond to the tiniest version 
of the screen, and then when it reaches a break point, it will apply for screens that size OR GREATER*/
@media only screen and (min-width: 600px) { 

}
@media only screen and (min-width: 960px) { 

}
@media only screen and (min-width: 1264px) {  

}
@media only screen and (min-width: 1904px) { 

}


/*Less-Than classes. Non-mobile-first. Your default classes in this case would correspond to the biggest version 
of the screen, and then when it reaches a break point, it will apply for screens that size OR LESS*/

/*less-than xl*/
@media (max-width : 1904px) {

}

/*less-than lg*/
@media (max-width : 1264px) {

}


/*less than md*/
@media (max-width : 960px) {

  /*Less than md size we want boxes, both horizontal and vertical, to just behave like rows.
  And we redo the margin-rules for the gutter helper classes.*/
  .al.al-boxes-gt-m {
    flex-wrap: wrap;  
  }
  .al.al-boxes.al-boxes-gt-m > .al,  .al.al-boxes.al-boxes-gt-m.al-uniform-5 > .al {
    flex: 0 0 100%;  
    -ms-flex: 0 0 100%;
  }
  .al.al-boxes.al-boxes-gt-m > .al,  .al.al-boxes.al-boxes-gt-m.al-uniform-4 > .al {
    flex: 0 0 100%;  
    -ms-flex: 0 0 100%;
  }
  .al.al-boxes.al-boxes-gt-m > .al,  .al.al-boxes.al-boxes-gt-m.al-uniform-3 > .al {
    flex: 0 0 100%;  
    -ms-flex: 0 0 100%;
  }
  .al.al-boxes.al-boxes-gt-m > .al,  .al.al-boxes.al-boxes-gt-m.al-uniform-2 > .al {
    flex: 0 0 100%;  
    -ms-flex: 0 0 100%;
  }
  .al.al-boxes-gt-m.al-g20 > .al:not(div:first-of-type) {
    margin-left:0px;
    margin-top:20px;
  }
  .al.al-boxes-gt-m.al-g30 > .al:not(div:first-of-type) {
    margin-left:0px;
    margin-top:30px;
  }
  .al.al-boxes-gt-m.al-g40 > .al:not(div:first-of-type) {
    margin-left:0px;
    margin-top:40px;
  } 

  .al.al-vertical.al-boxes-gt-m, .al.al-vertical.al-boxes-gt-m {
    display: flex;
    flex: 0 0 100%;
    -ms-flex: 0 0 100%;
    flex-direction: row;
    flex-wrap: wrap;
    box-sizing: border-box;
    position: relative; 
    height: auto;
  }
  .al.al-vertical.al-boxes-gt-m > .al {
    flex: 0 0 100%;
    -ms-flex: 0 0 100%;
  }
  .al-vertical.al-boxes-gt-m > .al {
    width: auto;
  }
  .al-vertical.al-boxes-gt-m.al-content-alt-secondary > .al {
    width: auto;
  }
  .al-vertical.al-boxes-gt-m > .al.al-boxes:not(.al-vertical) > .al {
    width: auto;
  }
  .al-vertical.al-boxes-gt-m > .al.al-boxes.al-content-alt-secondary:not(.al-vertical) > .al {
    height: auto;
  }
  
}

/*less-then sm*/
@media (max-width : 600px) {

}





/******************\
  
   TODOs and notes

\******************/

/**
 TODO: See 1.2 in BROKEN-XY-PARITY-NOTE. when you use al-vertical, it should be implicit
 that the content-mode is al-boxes.
*/

/*TODO: the al-boxes-gt-m and al-g20: Figure out how that will work with the center alignment for
boxes and the al-content-space* classes.*/

/*TODO: the al-uniform-3: fill that out for numbers 2-6 and make it work with al-vertical as well.*/

/*TODO: the al-uniform. It should work just like al-greedy. The wrapper know how many uniform elements there
are with like al-uniform-2 and then you can decide which 2 uniform width ones you want.*/

/*TODO: in the horizontal-mode-primary, the test 5,6,7 if you use al-content-center-v, that will 
force the elements to go frugal-height, which is the alternate secondary-dimension behavior. We don't
want that. I want that behavior to be triggered only by the al-content-alt-secondary class.*/

/**
 * BROKEN-XY-PARITY-NOTE: 
 * We don't treat the vertical and horizontal dimensions quite the same.
 *
 * 1: They treat their primary dimensions differently.
 * 
 *  1.1: We want to have elements that conserve vertical-space, but unlike horizontal conservation we need 
 *  to have the two options of either taking up the height and going no further (al-content-strict-height), 
 *  or creating extra height if we need it (which is the default behavior and the most common use-case) 
 *  You would just never have this kind of choice with a horizontal-conserving element because under absolutely 
 *  no circumstances would you want the content to spread out past the page horizontally and force the user 
 *  to scroll to the left and right. You only scroll up and down in website world, and that will be the case 
 *  as long as humans live in 3-dimensional space.
 *
 *  1.2: In horizontal-mode, you can choose the mode al-rows, al-boxes. 
 *  al-rows will take up all the horizontal space, and then stack vertically.
 *  al-boxes will conserve space according to greedy-frugal rules.
 *  But in vertical-mode (i.e. al-vertical) only al-boxes makes sense. If you don't 
 *  specify al-boxes, then what happens is that every element takes up 100vh, which is weird.
 * 
 */



/*
There was a layout case that's worth noting.
I had a full-screen thing that was supposed to appear when you pressed a button. A video and text.
For the desktop, this was a vertical-conserving set of elements. Easy enough. 100vh high.

Ok, well for mobile, it got really complicated.
Portrait mobile, we wanted the video to be flush with the top, preserve the 16x9 aspect ratio.
The 100vh thing wasn't appropriate. Needed to have it be vertically scrollable in that case.
And then for landscape mobile, we just wanted to show the video across the 100vh with all the t
text available underneath available with scrolling. Landscape implies that they're just interested
in the video. So there were several competing issues here. Lesson is that vertically-conserving elements
is not straightforward for mobile. 
*/

/*
overflow-x:hidden;
absolutely-positioned background elements tend to activate annoying horizontal scrollbars, and this is the fix.
however, safari apparently ignores that style for the body tag, and here's the S.O. post.
https://stackoverflow.com/questions/14270084/overflow-xhidden-doesnt-prevent-content-from-overflowing-in-mobile-browsers
So if it comes to this overflow problem in safari, a wrapper div inside the body tag with height:100%; and overflow-x:hidden;
is probably necessary.
*/

/*
TODO: 
generate-width problems are tough
https://stackoverflow.com/questions/12747045/css-shrink-a-parent-div-to-fit-one-childs-width-and-constrain-the-width-of-th
*/

/*
TODO: when you have an image in a flexbox in safari, it wants to stretch the image because of:

https://stackoverflow.com/questions/57516373/image-stretching-in-flexbox-in-safari;

it does this by default:
  align-items: stretch; 

So on your flexbox container, you need this:
  align-items: flex-start; 

  .thumbnail-box {
  padding: 0px; 
  display: flex; 
  justify-content:flex-start;
  align-items: flex-start; 
  width:230px;
}

.thumbnail-box > img {
  max-width: 100%;
  max-height: 100%;
}

Or

.thumbnail-box {
  padding: 0px; 
  display: flex; 
  justify-content:flex-start;
  align-items: flex-start; 
  width:230px;
}

.thumbnail-box > img {
  max-width:230px; 
  width: 100%; 
  object-fit: cover;
}


*/

